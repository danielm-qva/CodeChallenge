{"ast":null,"code":"import isPromise from 'is-promise';\n\nconst getErrorMessage = errorData => {\n  let message = errorData.message;\n\n  if (errorData.fieldErrors) {\n    errorData.fieldErrors.forEach(fErr => {\n      message += `\\nfield: ${fErr.field},  Object: ${fErr.objectName}, message: ${fErr.message}\\n`;\n    });\n  }\n\n  return message;\n}; // eslint-disable-next-line import/no-anonymous-default-export\n\n\nexport default (() => next => action => {\n  // If not a promise, continue on\n  if (!isPromise(action.payload)) {\n    return next(action);\n  }\n  /**\n   *\n   * The error middleware serves to dispatch the initial pending promise to\n   * the promise middleware, but adds a `catch`.\n   * It need not run in production\n   */\n\n\n  if (process.env.NODE_ENV === 'development') {\n    // Dispatch initial pending promise, but catch any errors\n    return next(action).catch(error => {\n      console.error(`${action.type} caught at middleware with reason: ${JSON.stringify(error.message)}.`);\n\n      if (error && error.response && error.response.data) {\n        const message = getErrorMessage(error.response.data);\n        console.error(`Actual cause: ${message}`);\n      }\n\n      return Promise.reject(error);\n    });\n  }\n\n  return next(action);\n});","map":{"version":3,"sources":["/home/daniel/Escritorio/Code Challenge /client/src/config/error-middleware.ts"],"names":["isPromise","getErrorMessage","errorData","message","fieldErrors","forEach","fErr","field","objectName","next","action","payload","process","env","NODE_ENV","catch","error","console","type","JSON","stringify","response","data","Promise","reject"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,YAAtB;;AAEA,MAAMC,eAAe,GAAIC,SAAD,IAAoB;AAC1C,MAAIC,OAAO,GAAGD,SAAS,CAACC,OAAxB;;AACA,MAAID,SAAS,CAACE,WAAd,EAA2B;AACzBF,IAAAA,SAAS,CAACE,WAAV,CAAsBC,OAAtB,CAA+BC,IAAD,IAAe;AAC3CH,MAAAA,OAAO,IAAK,YAAWG,IAAI,CAACC,KAAM,cAAaD,IAAI,CAACE,UAAW,cAAaF,IAAI,CAACH,OAAQ,IAAzF;AACD,KAFD;AAGD;;AACD,SAAOA,OAAP;AACD,CARD,C,CAUA;;;AACA,gBAAe,MAAOM,IAAD,IAAgBC,MAAD,IAAiB;AACnD;AACA,MAAI,CAACV,SAAS,CAACU,MAAM,CAACC,OAAR,CAAd,EAAgC;AAC9B,WAAOF,IAAI,CAACC,MAAD,CAAX;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE,MAAIE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,aAA7B,EAA4C;AAC1C;AACA,WAAOL,IAAI,CAACC,MAAD,CAAJ,CAAaK,KAAb,CAAoBC,KAAD,IAAgB;AACxCC,MAAAA,OAAO,CAACD,KAAR,CAAe,GAAEN,MAAM,CAACQ,IAAK,sCAAqCC,IAAI,CAACC,SAAL,CAAeJ,KAAK,CAACb,OAArB,CAA8B,GAAhG;;AACA,UAAIa,KAAK,IAAIA,KAAK,CAACK,QAAf,IAA2BL,KAAK,CAACK,QAAN,CAAeC,IAA9C,EAAoD;AAClD,cAAMnB,OAAO,GAAGF,eAAe,CAACe,KAAK,CAACK,QAAN,CAAeC,IAAhB,CAA/B;AACAL,QAAAA,OAAO,CAACD,KAAR,CAAe,iBAAgBb,OAAQ,EAAvC;AACD;;AAED,aAAOoB,OAAO,CAACC,MAAR,CAAeR,KAAf,CAAP;AACD,KARM,CAAP;AASD;;AACD,SAAOP,IAAI,CAACC,MAAD,CAAX;AACD,CAzBD","sourcesContent":["import isPromise from 'is-promise';\n\nconst getErrorMessage = (errorData: any) => {\n  let message = errorData.message;\n  if (errorData.fieldErrors) {\n    errorData.fieldErrors.forEach((fErr: any) => {\n      message += `\\nfield: ${fErr.field},  Object: ${fErr.objectName}, message: ${fErr.message}\\n`;\n    });\n  }\n  return message;\n};\n\n// eslint-disable-next-line import/no-anonymous-default-export\nexport default () => (next: any) => (action: any) => {\n  // If not a promise, continue on\n  if (!isPromise(action.payload)) {\n    return next(action);\n  }\n\n  /**\n   *\n   * The error middleware serves to dispatch the initial pending promise to\n   * the promise middleware, but adds a `catch`.\n   * It need not run in production\n   */\n  if (process.env.NODE_ENV === 'development') {\n    // Dispatch initial pending promise, but catch any errors\n    return next(action).catch((error: any) => {\n      console.error(`${action.type} caught at middleware with reason: ${JSON.stringify(error.message)}.`);\n      if (error && error.response && error.response.data) {\n        const message = getErrorMessage(error.response.data);\n        console.error(`Actual cause: ${message}`);\n      }\n\n      return Promise.reject(error);\n    });\n  }\n  return next(action);\n};\n"]},"metadata":{},"sourceType":"module"}